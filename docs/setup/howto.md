# How to setup your own PRISM

The repository for developing the PRISM application available on Github. It is devided into 2 main components:

- **[Backend](/setup/backend)** This contains the code that downloads and extracts the data from the various raw sources, performs calculations, and produces data products. It also contains the setup for the [Geoserver](http://geoserver.org/) that serves up the data products to the front-end.

- **[Frontend](/setup/frontend)** This contains the web application that connects to the [Geoserver](http://geoserver.org/) and allows users to view and interact with the data generated by the [backend](/setup/backend).

## Development Guidelines

In order to maximize code quality and compatibility of the PRISM platform across various development teams and countries, we have established guidelines on coding processes & code reviews. Please contact hello@ovio.org for any questions or concerns related to these processes.

### Code Style
Whenever possible, follow established best practices for code style in your language. For Python this means using [PEP8](https://www.python.org/dev/peps/pep-0008/). Linting tools can be used to enforce style.

### Code Structure

#### Single Repository
The PRISM code base is shared by multiple countries, each configuring the platform and developing country-specific features. The code is organized into a single repository (repo) containing both the frontend (or application) and the backend (or runners). The main goals of this organization are to avoid diverging changes and simplify deployments.

#### Master Branch
The base components and files will be hosted on the `master` branch. This branch will be the target of all feature development except country specific features. Any commits merged to `master` should be well-tested and ready for live release (and/or merging into a country branch). This branch will be protected on Github, and team members will not be able to merge without approval & hooks (1 approved code review + tests on CI). Merges to `master` will follow Pull Request Best Practices (see below).

We will periodically tag “released versions” of the code on `master` following [semantic versioning conventions](https://www.jvandemo.com/a-simple-guide-to-semantic-versioning/). These versions will have undergone thorough QA in a live-staging environment and should be considered safe for deployment and/or merging into a country branch.

#### Country Branch
Each country will own a `country_name-master` branch which will be a combination of the primary `master` branch and any country-specific changes, features, or configuration which may have been added. If developing a country-specific feature, pull requests can be targeted directly to a country branch, however, developers are encouraged to develop features to `master` whenever possible so that all countries can share advances in the codebase. Any commits published to `master` can be merged to a country branch. Whenever a country deploys a new version live, a tag with the format `country_name-release-master_version-deploy_number` should be created. This allows countries to deploy multiple versions of custom country code between tagged master versions if necessary, but will create a record of exactly what version of code is deployed in a given country at any point in time.

Merges to `country_name-master` branches will also be protected and should follow Pull Request Best Practices (just like the regular `master`).

#### Configuration First Approach
Divergence between `master` and country specific branches is inevitable. However, we encourage every team to take a “configuration first” approach and develop abstracted and configurable features instead of making hard-coded changes to the codebase whenever possible. Even if a new feature seems like it will only be used by one country, it will make it easier to maintain if it is seen as a feature available on `master` and “activated” only for this country via configuration files.

### Pull Requests - Best Practices

#### Small and Atomic Pull Requests
Engineers should keep their Pull Requests small and granular PRs. PRs should represent an Atomic change and have a **self explaining name**. There is no hard and fast rule, but generally if a pull request involves more than a few 100 lines of code changed, it should be separated into several smaller PRs that each address an independent change.

#### Pull Request Documentation
To help the reviewer understand the changes that were made and do a better job efficiently code reviewing, a PR should have clear documentation. This should include a concise description of the changes made at a high level, screenshots of the new interface (for user-facing changes), as well as any questions, concerns, or specific areas that especially need testing. If the PR is related to specific Issues documented in Github, it should reference those issues in the description (e.g. “Fixes #12”).

The reviewer should post any questions and discussion of the proposed changes on the Github PR interface so that discussions & design considerations can be referenced later on if needed.

#### Merge - Squash Commits and PR Merges
When merging a PR, commits should be squashed to keep the master branches clean (so each PR corresponds to a single commit in the `master` history). You can now do that automatically when merging your PR through the GitHub web interface. Alternatively you can use the `git rebase master -i` command to control the process. Either way, the single squashed commit to `master` should have a concise one-line description (no more than 100 characters) that contains a reference (e.g. #15) to the Github PR number.

#### One Approver Rule
Pull Requests should NOT be merged to a `country_name-master` or `master` branch without being approved by another team member. Once your branch is ready, you should create a Pull Request directed at the appropriate branch and assign someone who is capable of reviewing this part of the code. Merges of PRs are blocked in Github unless the PR receives at least one approval from a developer.

#### Reading
[The anatomy of a perfect pull request](https://medium.com/@hugooodias/the-anatomy-of-a-perfect-pull-request-567382bb6067)


### Tests

#### Write Clear Tests
Writing good tests has many benefits. One of them is to make sure the code does what it should. If there are good tests that pass, chances are that the code works. However, this is not a replacement for running code before submitting it to a pull request. Running code in a QA environment can reveal bugs caused by the environment being different, or something that wasn’t tested for.

#### Tests as Documentation
There is another big reason to write tests: tests double as documentation. An experienced developer will look at a user story and start by writing an acceptance test for it. This is another reason good user stories are needed, so developers can write good tests and ultimately good pull requests.

When another developer comes along to review the code someone wrote, it can be helpful if they can look at the tests to see what this pull request covers.